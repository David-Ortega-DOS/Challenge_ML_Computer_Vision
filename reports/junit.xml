<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="1" skipped="0" tests="1" time="44.681" timestamp="2025-11-23T23:25:22.242933-05:00" hostname="DESKTOP-5EH2P39"><testcase classname="tests.api.test_api_dataset" name="test_api_recall_on_subset" time="22.540"><failure message="IndexError: list index out of range">test_images = ['/mnt/d/Github/Challenge_ML_Computer_Vision/data/test/images/2023-02-28-19-15-51_summary-bag_26_jpeg_jpg.rf.c6c10978a...g', '/mnt/d/Github/Challenge_ML_Computer_Vision/data/test/images/data_233_jpg.rf.bb340e102fd21b29f22ae6d9a2be142b.jpg']
yolo_labels = &lt;function yolo_labels.&lt;locals&gt;._read at 0x7f27ca0ad480&gt;

    @pytest.mark.slow
    def test_api_recall_on_subset(test_images, yolo_labels):
        iou_th = float(os.environ.get("IOU_TH", 0.5))
    
        matched = 0
        total = 0
    
        for img_path in test_images:
            img = cv2.imread(img_path)
            H, W = img.shape[:2]
            buf = _to_buf(img)
    
&gt;           resp = client.post("/predict", files={"file": ("img.jpg", buf, "image/jpeg")})

tests/api/test_api_dataset.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.10/site-packages/starlette/testclient.py:593: in post
    return super().post(
.venv/lib/python3.10/site-packages/httpx/_client.py:1144: in post
    return self.request(
.venv/lib/python3.10/site-packages/starlette/testclient.py:484: in request
    return super().request(
.venv/lib/python3.10/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
.venv/lib/python3.10/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
.venv/lib/python3.10/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
.venv/lib/python3.10/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
.venv/lib/python3.10/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
.venv/lib/python3.10/site-packages/starlette/testclient.py:377: in handle_request
    raise exc
.venv/lib/python3.10/site-packages/starlette/testclient.py:374: in handle_request
    portal.call(self.app, scope, receive, send)
.venv/lib/python3.10/site-packages/anyio/from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/usr/lib/python3.10/concurrent/futures/_base.py:458: in result
    return self.__get_result()
/usr/lib/python3.10/concurrent/futures/_base.py:403: in __get_result
    raise self._exception
.venv/lib/python3.10/site-packages/anyio/from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
.venv/lib/python3.10/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
.venv/lib/python3.10/site-packages/starlette/applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.10/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
.venv/lib/python3.10/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
.venv/lib/python3.10/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
.venv/lib/python3.10/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.10/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.10/site-packages/starlette/routing.py:715: in __call__
    await self.middleware_stack(scope, receive, send)
.venv/lib/python3.10/site-packages/starlette/routing.py:735: in app
    await route.handle(scope, receive, send)
.venv/lib/python3.10/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
.venv/lib/python3.10/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
.venv/lib/python3.10/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
.venv/lib/python3.10/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv/lib/python3.10/site-packages/starlette/routing.py:73: in app
    response = await f(request)
.venv/lib/python3.10/site-packages/fastapi/routing.py:301: in app
    raw_response = await run_endpoint_function(
.venv/lib/python3.10/site-packages/fastapi/routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

file = UploadFile(filename='img.jpg', size=52643, headers=Headers({'content-disposition': 'form-data; name="file"; filename="img.jpg"', 'content-type': 'image/jpeg'}))

    @app.post("/predict", status_code=200, response_model=PredictionResponse)
    async def post_predict(file: UploadFile = File(...)) -&gt; PredictionResponse:
        # 1. Verificar el estado del modelo
        if MODEL is None:
            raise HTTPException(status_code=503, detail="Model is not loaded. Cannot run inference.")
    
        # 2. Leer el archivo de imagen (como bytes)
        image_bytes = await file.read()
    
        # 3. Ejecutar Inferencia
        try:
            # 1. Convertir los bytes a un array numpy (buffer)
            nparr = np.frombuffer(image_bytes, np.uint8)
    
            # 2. Decodificar el array numpy en una imagen OpenCV (BGR)
            img_bgr = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    
            if img_bgr is None:
                raise ValueError("Invalid image file or unsupported format.")
    
            # YOLO.predict() acepta el array numpy decodificado (BGR)
            results_list = MODEL.predict(
                source=img_bgr, # Pasar el array NumPy, no los bytes
                conf=0.25,
                iou=0.45,
                imgsz=800,
                verbose=False
            )
    
        except Exception as e:
            # El 500 es causado por un error en la conversión o decodificación
            print(f"Error during image processing or YOLO inference: {e}")
            # Usar HTTPException 400 si la imagen es inválida, 500 si es un error del modelo.
            raise HTTPException(status_code=500, detail="Inference failed after image decoding.")
    
        # 4. Procesar y Formatear la Respuesta
        detections = []
    
        if results_list:
            results = results_list[0]
    
            if results.boxes is not None:
                # Extraer los tensores de la GPU (si aplica) o CPU
                boxes = results.boxes.xyxy.cpu().numpy()
                confidences = results.boxes.conf.cpu().numpy()
                class_ids = results.boxes.cls.cpu().numpy().astype(int)
    
                for box, conf, cls_id in zip(boxes, confidences, class_ids):
                    detections.append(Detection(
                        # Convertir np.array a lista para JSON
                        box=box.tolist(),
                        confidence=float(conf),
                        class_id=int(cls_id),
&gt;                       class_name=CLASSES_META['names'][cls_id]
                    ))
E                   IndexError: list index out of range

challenge/api.py:126: IndexError</failure></testcase></testsuite></testsuites>